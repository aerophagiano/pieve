<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STL Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #viewer {
            width: 100%;
            height: 100%;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }
        
        #fileName {
            margin-bottom: 10px;
            padding: 8px;
            background: #333;
            border-radius: 4px;
            font-size: 14px;
            color: #ccc;
        }
        
        .control-group {
            margin-bottom: 8px;
        }
        
        .control-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        .control-group input[type="range"] {
            width: 150px;
        }
        
        .control-group input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 4px;
            backdrop-filter: blur(10px);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            backdrop-filter: blur(10px);
            display: none;
            min-width: 250px;
        }
        
        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #007acc;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        .progress-container {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin: 15px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #007acc, #00a8ff);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .loading-text {
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .loading-detail {
            font-size: 12px;
            color: #ccc;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            #controls {
                top: 5px;
                left: 5px;
                padding: 8px;
                font-size: 14px;
            }
            
            .control-group input[type="range"] {
                width: 120px;
            }
            
            #info {
                bottom: 5px;
                left: 5px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="viewer"></div>
        
        <div id="controls">
            <div id="fileName"></div>
            <div class="control-group">
                <label>Zoom: <span id="zoomValue">1.0</span></label>
                <input type="range" id="zoomSlider" min="0.1" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>Color:</label>
                <input type="color" id="colorPicker" value="#888888">
            </div>
        </div>
        
        <div id="loading">
            <div class="spinner"></div>
            <div class="loading-text">Loading STL...</div>
            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="loading-detail" id="loadingDetail">Preparing...</div>
        </div>
        
        <div id="info">
            <div>Touch/drag to rotate â€¢ Pinch to zoom</div>
            <div id="modelInfo"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class STLViewer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.mesh = null;
                this.controls = null;
                
                this.init();
                this.setupEventListeners();
                this.loadSTLFromURL();
                this.animate();
            }
            
            init() {
                const container = document.getElementById('viewer');
                
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1a1a1a);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    container.clientWidth / container.clientHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 0, 50);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.appendChild(this.renderer.domElement);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                this.scene.add(directionalLight);
                
                const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
                directionalLight2.position.set(-50, -50, -50);
                this.scene.add(directionalLight2);
                
                // Simple touch controls
                this.setupTouchControls();
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            setupTouchControls() {
                let isRotating = false;
                let isPanning = false;
                let previousTouch = { x: 0, y: 0 };
                let previousDistance = 0;
                let rotationX = 0;
                let rotationY = 0;
                let currentZoom = 1;
                let panX = 0;
                let panY = 0;
                
                const canvas = this.renderer.domElement;
                
                // Helper functions
                const getTouchDistance = (touch1, touch2) => {
                    const dx = touch1.clientX - touch2.clientX;
                    const dy = touch1.clientY - touch2.clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                };
                
                const getTouchCenter = (touch1, touch2) => {
                    return {
                        x: (touch1.clientX + touch2.clientX) / 2,
                        y: (touch1.clientY + touch2.clientY) / 2
                    };
                };
                
                const updateZoomSlider = (zoom) => {
                    const zoomSlider = document.getElementById('zoomSlider');
                    const zoomValue = document.getElementById('zoomValue');
                    zoomSlider.value = zoom;
                    zoomValue.textContent = zoom.toFixed(1);
                };
                
                // Mouse controls
                canvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (e.button === 0) { // Left click - rotate
                        isRotating = true;
                        previousTouch.x = e.clientX;
                        previousTouch.y = e.clientY;
                    } else if (e.button === 2) { // Right click - pan
                        isPanning = true;
                        previousTouch.x = e.clientX;
                        previousTouch.y = e.clientY;
                    }
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!this.mesh) return;
                    
                    const deltaX = e.clientX - previousTouch.x;
                    const deltaY = e.clientY - previousTouch.y;
                    
                    if (isRotating) {
                        rotationY += deltaX * 0.01;
                        rotationX += deltaY * 0.01;
                        
                        this.mesh.rotation.x = rotationX;
                        this.mesh.rotation.y = rotationY;
                    } else if (isPanning) {
                        panX += deltaX * 0.05;
                        panY -= deltaY * 0.05;
                        
                        this.mesh.position.x = panX;
                        this.mesh.position.y = panY;
                    }
                    
                    previousTouch.x = e.clientX;
                    previousTouch.y = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    isRotating = false;
                    isPanning = false;
                });
                
                // Mouse wheel zoom
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    if (!this.mesh) return;
                    
                    const zoomSpeed = 0.1;
                    const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
                    currentZoom = Math.max(0.1, Math.min(3, currentZoom + delta));
                    
                    this.mesh.scale.setScalar(currentZoom);
                    updateZoomSlider(currentZoom);
                });
                
                // Disable context menu
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Touch controls
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    
                    if (e.touches.length === 1) {
                        // Single touch - rotate
                        isRotating = true;
                        previousTouch.x = e.touches[0].clientX;
                        previousTouch.y = e.touches[0].clientY;
                    } else if (e.touches.length === 2) {
                        // Two finger touch - zoom and pan
                        isRotating = false;
                        previousDistance = getTouchDistance(e.touches[0], e.touches[1]);
                        previousTouch = getTouchCenter(e.touches[0], e.touches[1]);
                    }
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.mesh) return;
                    
                    if (e.touches.length === 1 && isRotating) {
                        // Single touch - rotate
                        const deltaX = e.touches[0].clientX - previousTouch.x;
                        const deltaY = e.touches[0].clientY - previousTouch.y;
                        
                        rotationY += deltaX * 0.01;
                        rotationX += deltaY * 0.01;
                        
                        this.mesh.rotation.x = rotationX;
                        this.mesh.rotation.y = rotationY;
                        
                        previousTouch.x = e.touches[0].clientX;
                        previousTouch.y = e.touches[0].clientY;
                    } else if (e.touches.length === 2) {
                        // Two finger touch - zoom and pan
                        const currentDistance = getTouchDistance(e.touches[0], e.touches[1]);
                        const currentCenter = getTouchCenter(e.touches[0], e.touches[1]);
                        
                        // Pinch zoom
                        if (previousDistance > 0) {
                            const zoomFactor = currentDistance / previousDistance;
                            currentZoom = Math.max(0.1, Math.min(3, currentZoom * zoomFactor));
                            this.mesh.scale.setScalar(currentZoom);
                            updateZoomSlider(currentZoom);
                        }
                        
                        // Two finger pan
                        if (previousTouch.x !== 0 && previousTouch.y !== 0) {
                            const deltaX = currentCenter.x - previousTouch.x;
                            const deltaY = currentCenter.y - previousTouch.y;
                            
                            panX += deltaX * 0.05;
                            panY -= deltaY * 0.05;
                            
                            this.mesh.position.x = panX;
                            this.mesh.position.y = panY;
                        }
                        
                        previousDistance = currentDistance;
                        previousTouch = currentCenter;
                    }
                });
                
                canvas.addEventListener('touchend', (e) => {
                    if (e.touches.length === 0) {
                        isRotating = false;
                        previousDistance = 0;
                        previousTouch = { x: 0, y: 0 };
                    } else if (e.touches.length === 1) {
                        // Transition from two finger to one finger
                        isRotating = true;
                        previousTouch.x = e.touches[0].clientX;
                        previousTouch.y = e.touches[0].clientY;
                        previousDistance = 0;
                    }
                });
                
                // Update zoom slider when manually changed
                const zoomSlider = document.getElementById('zoomSlider');
                zoomSlider.addEventListener('input', (e) => {
                    currentZoom = parseFloat(e.target.value);
                });
            }
            
            setupEventListeners() {
                const zoomSlider = document.getElementById('zoomSlider');
                const colorPicker = document.getElementById('colorPicker');
                const zoomValue = document.getElementById('zoomValue');
                
                zoomSlider.addEventListener('input', (e) => {
                    const zoom = parseFloat(e.target.value);
                    zoomValue.textContent = zoom.toFixed(1);
                    if (this.mesh) {
                        this.mesh.scale.setScalar(zoom);
                    }
                });
                
                colorPicker.addEventListener('change', (e) => {
                    if (this.mesh) {
                        this.mesh.material.color.setHex(parseInt(e.target.value.replace('#', '0x')));
                    }
                });
            }
            
            getSTLPathFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get('stl') || 'model.stl'; // Default to 'model.stl' if no parameter
            }
            
            async loadSTLFromURL() {
                const stlPath = this.getSTLPathFromURL();
                const fileName = stlPath.split('/').pop();
                
                document.getElementById('fileName').textContent = `Loading: ${fileName}`;
                this.showLoading('Fetching STL file...');
                
                try {
                    const response = await fetch(stlPath);
                    
                    if (!response.ok) {
                        throw new Error(`Failed to load STL: ${response.status} ${response.statusText}`);
                    }
                    
                    const contentLength = response.headers.get('content-length');
                    const total = contentLength ? parseInt(contentLength, 10) : 0;
                    
                    let loaded = 0;
                    const reader = response.body.getReader();
                    const chunks = [];
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        
                        if (done) break;
                        
                        chunks.push(value);
                        loaded += value.length;
                        
                        if (total > 0) {
                            const progress = (loaded / total) * 100;
                            this.updateProgress(progress, `Downloaded: ${this.formatBytes(loaded)} / ${this.formatBytes(total)}`);
                        } else {
                            this.updateProgress(0, `Downloaded: ${this.formatBytes(loaded)}`);
                        }
                    }
                    
                    // Combine chunks into single array buffer
                    this.updateProgress(100, 'Processing STL data...');
                    const buffer = new ArrayBuffer(loaded);
                    const uint8Array = new Uint8Array(buffer);
                    let offset = 0;
                    
                    for (const chunk of chunks) {
                        uint8Array.set(chunk, offset);
                        offset += chunk.length;
                    }
                    
                    // Parse the STL
                    this.parseSTL(buffer);
                    document.getElementById('fileName').textContent = `Loaded: ${fileName}`;
                    this.hideLoading();
                    
                } catch (error) {
                    console.error('Error loading STL:', error);
                    document.getElementById('fileName').textContent = `Error: ${fileName}`;
                    this.hideLoading();
                    alert(`Error loading STL file: ${error.message}`);
                }
            }
            
            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            }
            
            showLoading(message) {
                const loading = document.getElementById('loading');
                const loadingDetail = document.getElementById('loadingDetail');
                loading.style.display = 'block';
                loadingDetail.textContent = message;
                this.updateProgress(0);
            }
            
            hideLoading() {
                document.getElementById('loading').style.display = 'none';
            }
            
            updateProgress(percent, detail = '') {
                const progressBar = document.getElementById('progressBar');
                const loadingDetail = document.getElementById('loadingDetail');
                
                progressBar.style.width = `${Math.min(100, Math.max(0, percent))}%`;
                if (detail) {
                    loadingDetail.textContent = detail;
                }
            }
            
            parseSTL(buffer) {
                const dataView = new DataView(buffer);
                const isASCII = this.isASCIISTL(buffer);
                
                let geometry;
                if (isASCII) {
                    geometry = this.parseASCIISTL(new TextDecoder().decode(buffer));
                } else {
                    geometry = this.parseBinarySTL(dataView);
                }
                
                // Remove existing mesh
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                }
                
                // Create material
                const material = new THREE.MeshLambertMaterial({ 
                    color: document.getElementById('colorPicker').value 
                });
                
                // Create mesh
                this.mesh = new THREE.Mesh(geometry, material);
                this.scene.add(this.mesh);
                
                // Center and scale the model
                this.centerModel();
                
                // Update info
                const triangles = geometry.attributes.position.count / 3;
                document.getElementById('modelInfo').textContent = `Triangles: ${triangles}`;
            }
            
            isASCIISTL(buffer) {
                const header = new TextDecoder().decode(buffer.slice(0, 80));
                return header.toLowerCase().includes('solid');
            }
            
            parseBinarySTL(dataView) {
                const triangleCount = dataView.getUint32(80, true);
                const geometry = new THREE.BufferGeometry();
                
                const vertices = [];
                const normals = [];
                
                let offset = 84;
                for (let i = 0; i < triangleCount; i++) {
                    // Normal vector
                    const nx = dataView.getFloat32(offset, true);
                    const ny = dataView.getFloat32(offset + 4, true);
                    const nz = dataView.getFloat32(offset + 8, true);
                    offset += 12;
                    
                    // Three vertices
                    for (let j = 0; j < 3; j++) {
                        const x = dataView.getFloat32(offset, true);
                        const y = dataView.getFloat32(offset + 4, true);
                        const z = dataView.getFloat32(offset + 8, true);
                        
                        vertices.push(x, y, z);
                        normals.push(nx, ny, nz);
                        
                        offset += 12;
                    }
                    
                    // Skip attribute byte count
                    offset += 2;
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                
                return geometry;
            }
            
            parseASCIISTL(text) {
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const normals = [];
                
                const lines = text.split('\n');
                let currentNormal = null;
                
                for (let line of lines) {
                    line = line.trim();
                    
                    if (line.startsWith('facet normal')) {
                        const parts = line.split(/\s+/);
                        currentNormal = [
                            parseFloat(parts[2]),
                            parseFloat(parts[3]),
                            parseFloat(parts[4])
                        ];
                    } else if (line.startsWith('vertex')) {
                        const parts = line.split(/\s+/);
                        vertices.push(
                            parseFloat(parts[1]),
                            parseFloat(parts[2]),
                            parseFloat(parts[3])
                        );
                        if (currentNormal) {
                            normals.push(...currentNormal);
                        }
                    }
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                if (normals.length > 0) {
                    geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                } else {
                    geometry.computeVertexNormals();
                }
                
                return geometry;
            }
            
            centerModel() {
                if (!this.mesh) return;
                
                // Compute bounding box
                const box = new THREE.Box3().setFromObject(this.mesh);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                // Center the model
                this.mesh.position.sub(center);
                
                // Scale to fit in view
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 30 / maxDim;
                this.mesh.scale.setScalar(scale);
                
                // Update zoom slider
                document.getElementById('zoomSlider').value = scale;
                document.getElementById('zoomValue').textContent = scale.toFixed(1);
            }
            
            onWindowResize() {
                const container = document.getElementById('viewer');
                this.camera.aspect = container.clientWidth / container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(container.clientWidth, container.clientHeight);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize the viewer when page loads
        window.addEventListener('load', () => {
            new STLViewer();
        });
    </script>
</body>
</html>